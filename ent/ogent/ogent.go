// Code generated by entc, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"t/ent"
	"t/ent/users"

	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateUsers handles POST /users-slice requests.
func (h *OgentHandler) CreateUsers(ctx context.Context, req CreateUsersReq) (CreateUsersRes, error) {
	b := h.client.Users.Create()
	// Add all fields.
	b.SetUser("syui")
	//b.SetUser(req.User)
	if v, ok := req.Chara.Get(); ok {
		b.SetChara(v)
	}
	if v, ok := req.Skill.Get(); ok {
		b.SetSkill(v)
	}
	if v, ok := req.Hp.Get(); ok {
		b.SetHp(v)
	}
	if v, ok := req.Attack.Get(); ok {
		b.SetAttack(v)
	}
	if v, ok := req.Defense.Get(); ok {
		b.SetDefense(v)
	}
	if v, ok := req.Critical.Get(); ok {
		b.SetCritical(v)
	}
	if v, ok := req.Battle.Get(); ok {
		b.SetBattle(v)
	}
	if v, ok := req.Win.Get(); ok {
		b.SetWin(v)
	}
	if v, ok := req.Day.Get(); ok {
		b.SetDay(v)
	}
	if v, ok := req.Percentage.Get(); ok {
		b.SetPercentage(v)
	}
	if v, ok := req.Limit.Get(); ok {
		b.SetLimit(v)
	}
	if v, ok := req.Status.Get(); ok {
		b.SetStatus(v)
	}
	if v, ok := req.Comment.Get(); ok {
		b.SetComment(v)
	}
	if v, ok := req.CreatedAt.Get(); ok {
		b.SetCreatedAt(v)
	}
	if v, ok := req.Next.Get(); ok {
		b.SetNext(v)
	}
	if v, ok := req.UpdatedAt.Get(); ok {
		b.SetUpdatedAt(v)
	}
	if v, ok := req.URL.Get(); ok {
		b.SetURL(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Users.Query().Where(users.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUsersCreate(e), nil
}

// ReadUsers handles GET /users-slice/{id} requests.
func (h *OgentHandler) ReadUsers(ctx context.Context, params ReadUsersParams) (ReadUsersRes, error) {
	q := h.client.Users.Query().Where(users.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewUsersRead(e), nil
}

// UpdateUsers handles PATCH /users-slice/{id} requests.
func (h *OgentHandler) UpdateUsers(ctx context.Context, req UpdateUsersReq, params UpdateUsersParams) (UpdateUsersRes, error) {
	b := h.client.Users.UpdateOneID(params.ID)
	// Add all fields.
	//if v, ok := req.Chara.Get(); ok {
	//	b.SetChara(v)
	//}
	//if v, ok := req.Hp.Get(); ok {
	//	b.SetHp(v)
	//}
	//if v, ok := req.Attack.Get(); ok {
	//	b.SetAttack(v)
	//}
	//if v, ok := req.Defense.Get(); ok {
	//	b.SetDefense(v)
	//}
	//if v, ok := req.Critical.Get(); ok {
	//	b.SetCritical(v)
	//}
	//if v, ok := req.Battle.Get(); ok {
	//	b.SetBattle(v)
	//}
	//if v, ok := req.Win.Get(); ok {
	//	b.SetWin(v)
	//}
	//if v, ok := req.Day.Get(); ok {
	//	b.SetDay(v)
	//}
	//if v, ok := req.Percentage.Get(); ok {
	//	b.SetPercentage(v)
	//}
	//if v, ok := req.Limit.Get(); ok {
	//	b.SetLimit(v)
	//}
	//if v, ok := req.Comment.Get(); ok {
	//	b.SetComment(v)
	//}
	//if v, ok := req.Next.Get(); ok {
	//	b.SetNext(v)
	//}
	//if v, ok := req.UpdatedAt.Get(); ok {
	//	b.SetUpdatedAt(v)
	//}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Users.Query().Where(users.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUsersUpdate(e), nil
}

// DeleteUsers handles DELETE /users-slice/{id} requests.
func (h *OgentHandler) DeleteUsers(ctx context.Context, params DeleteUsersParams) (DeleteUsersRes, error) {
	if params.ID != 1 {
		err := h.client.Users.DeleteOneID(params.ID).Exec(ctx)
		if err != nil {
			switch {
			case ent.IsNotFound(err):
				return &R404{
					Code:   http.StatusNotFound,
					Status: http.StatusText(http.StatusNotFound),
					Errors: rawError(err),
				}, nil
			case ent.IsConstraintError(err):
				return &R409{
					Code:   http.StatusConflict,
					Status: http.StatusText(http.StatusConflict),
					Errors: rawError(err),
				}, nil
			default:
				// Let the server handle the error.
				return nil, err
			}
		}
	}
	return new(DeleteUsersNoContent), nil
}

// ListUsers handles GET /users-slice requests.
func (h *OgentHandler) ListUsers(ctx context.Context, params ListUsersParams) (ListUsersRes, error) {
	q := h.client.Users.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListUsersOKApplicationJSON(NewUsersLists(es)), nil
}
